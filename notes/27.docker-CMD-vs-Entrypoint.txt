ğŸš€ First: What are CMD and ENTRYPOINT?
----------------------------------------

These are instructions in a Dockerfile that define what the container does when it starts.

Think of it like:

ENTRYPOINT â†’ the main command the container will always run.

CMD â†’ the default arguments passed to that command â€” you can override them when running the container.

ğŸ” Simple Analogy: Burger Shop
--------------------------------

ENTRYPOINT is the shop itself: It always makes burgers.

CMD is the default burger recipe (cheese, tomato, no onion).

You can say: "Make me a spicy burger instead!" â†’ and override the CMD.

âœ… CMD â€“ Set Default Command or Args
----------------------------------------

CMD ["python", "app.py"]

If you donâ€™t give any command when running the container, this will be run.

But if you do give a command, it overrides the CMD.

Example:

docker run myimage            â†’ runs: python app.py
docker run myimage ls -l      â†’ runs: ls -l   (CMD overridden)

âœ… ENTRYPOINT â€“ Forces a Command
----------------------------------

ENTRYPOINT ["python"]
CMD ["app.py"]

Together, this becomes:

docker run myimage            â†’ runs: python app.py
docker run myimage test.py    â†’ runs: python test.py

ğŸ§  Here, ENTRYPOINT is fixed (python), and CMD is optional/default arguments.

ğŸ§¨ What if you use shell form?
If you write:

CMD python app.py

It runs using /bin/sh -c, which may behave differently in terms of signals or when ENTRYPOINT is combined.

Prefer exec form (JSON array):

CMD ["python", "app.py"]

ğŸ’¥ What happens when both are set?
-------------------------------------

ENTRYPOINT ["echo"]
CMD ["Hello"]

Runs:

echo Hello

Override CMD:

docker run myimage World
â†’ echo World

Override ENTRYPOINT too:

docker run --entrypoint ls myimage -l
â†’ ls -l

ğŸ¤¯ Key Differences

| Feature           | CMD                     | ENTRYPOINT                 |
| ----------------- | ----------------------- | -------------------------- |
| Purpose           | Default command or args | Fixed command              |
| Can be overridden | Yes (with `docker run`) | Not easily (unless forced) |
| Use case          | Flexible defaults       | Fixed behavior             |
| Form              | Shell or exec form      | Prefer exec form           |


===========
Additional:
===========

ğŸ’¡ Imagine this:
-----------------

When you run a Docker container, you are basically saying:

"Hey Docker, start a mini-computer (a container), and run something inside it."

But... run what? ğŸ¤”

Thatâ€™s exactly where CMD and ENTRYPOINT come in.
They tell Docker what to run inside the container when it starts.


ğŸ“¦ Your Container is Like a Little Boxed App
-------------------------------------------------

The container has its own filesystem (e.g., based on Ubuntu or Alpine)

It has its own processes (like running Python, Node.js, etc.)

But it shares your real PCâ€™s kernel (weâ€™ll explain that shortly)

But when the container starts, Docker needs to know what to actually do â€” like:

Should it start a web server?

Should it run a Python script?

Should it just sleep?

Thatâ€™s why CMD or ENTRYPOINT are used:

ğŸ‘‰ They define what the container runs when it starts.

ğŸ–¥ï¸ What about terminals?
----------------------------

Letâ€™s say you open a terminal and run:

docker run ubuntu

Without CMD or ENTRYPOINT, the container has no idea what to do, so it just starts and stops.

But if you run:

docker run -it ubuntu bash

Now you are saying:

"Run an Ubuntu container and start the bash shell in it."

This creates an interactive terminal session inside the container.

You are not using your host PCâ€™s Ubuntu â€” youâ€™re now inside the container's tiny Ubuntu system.

So Docker is using your real terminal, but connected to a shell running inside the container.

ğŸ”„ So where does CMD/ENTRYPOINT fit in?

Letâ€™s say your Dockerfile is like this:

FROM python:3.6
CMD ["python", "app.py"]

Now when someone runs:

docker run myimage

â†’ Docker will start a container and run: python app.py
â†’ Because thatâ€™s what you told it to do with CMD.

So even if you're not using a terminal, you can still tell the container what its main job is.

ğŸ¤” So why not just always run stuff manually?
----------------------------------------------

Good question. Answer: Automation.

If you always had to type the command every time the container starts, it would be annoying.

CMD/ENTRYPOINT make your Docker images self-contained apps.

This way, your image knows what itâ€™s supposed to do â€” no manual typing needed.


ğŸ§  What does â€œDocker uses host kernelâ€ mean?
-----------------------------------------------

Your real PC has an operating system kernel (Linux kernel if on Linux).

Docker does not emulate a full OS â€” it shares your host's kernel.

This is different from full Virtual Machines (VMs), which use their own kernel.

So when you run a container:

It looks like a separate system (has its own files, processes),

But it still runs using the host machineâ€™s kernel (which makes it fast and lightweight).

If youâ€™re on Windows:

Docker usually runs a lightweight Linux VM behind the scenes, using WSL2 or Hyper-V.

So your container actually runs inside that VM, not directly on Windows.








