ğŸ§  First, what's the problem?

Youâ€™ve learned how to run one Docker container with docker run, like:

docker run -d -p 8080:80 nginx

But what if your app needs:

A web server (e.g. Node.js or Flask)

A database (e.g. MySQL or MongoDB)

Maybe a Redis cache

And they all need to talk to each other?

Typing docker run multiple times, linking containers, managing networks, passing environment variablesâ€¦ ğŸ˜µ That gets messy fast.

ğŸ¯ What is Docker Compose?
----------------------------

Docker Compose is a tool that lets you:

Define and run multiple containers (a whole app) using one file.

âœ… Instead of starting containers manually with long docker run commands, you just:

Write a simple file called docker-compose.yml

Run one command:

docker-compose up

Boom ğŸ’¥ â€” all containers start together, automatically connected, and ready to go.

ğŸ“ Example: A simple docker-compose.yml
------------------------------------------

Letâ€™s say you have a Node.js app and a MongoDB database. Hereâ€™s what docker-compose.yml might look like:

version: "3.8"
services:
  app:
    image: my-node-app
    ports:
      - "3000:3000"
    depends_on:
      - db

  db:
    image: mongo
    ports:
      - "27017:27017"

Now just run:

docker-compose up

And it will:

	Start your Node.js app

	Start MongoDB

	Connect them together

	Forward the ports


ğŸ§© Key Concepts

| Term            | Meaning                                                              |
| --------------- | -------------------------------------------------------------------- |
| **services**    | Each container you want to run (e.g., web, db, redis)                |
| **image**       | The Docker image to use                                              |
| **ports**       | Maps container port â†’ your host (e.g., 3000:3000)                    |
| **volumes**     | If you want to store data or sync local files with container         |
| **depends\_on** | Tells Compose to start one service **after** another                 |
| **networks**    | Docker Compose automatically connects services to talk to each other |


ğŸ“¦ Benefits of Docker Compose
---------------------------------

âœ… One file to define your whole app stack
âœ… Makes collaboration easy â€” just share the docker-compose.yml
âœ… Great for development and testing
âœ… Supports environment variables, volumes, databases, etc.

ğŸ§ª Real-World Example
----------------------

Letâ€™s say youâ€™re working on a React frontend + Flask backend + PostgreSQL database.

You could define all 3 in one docker-compose.yml and just run:

docker-compose up

-------------------------------------
Now Docker compose File explained:
-------------------------------------

âœ… First: Does the file have to be named docker-compose.yml?
No, not strictly.

But by default, Docker Compose looks for a file named docker-compose.yml.

So unless you specify a custom name, you should name it:

docker-compose.yml

If you use a different name (like my-app-compose.yml), you must run Compose like:

docker-compose -f my-app-compose.yml up

So yes, it's recommended to name it docker-compose.yml for simplicity âœ…

ğŸ“¦ Letâ€™s Build a Sample Compose File
-----------------------------------------

Letâ€™s say you're building a project that has:

A Flask app (Python web backend)

A PostgreSQL database

ğŸ“ docker-compose.yml
------------------------

version: "3.8"           # ğŸ‘ˆ Defines the version of Docker Compose syntax we're using

services:                # ğŸ‘ˆ Begin listing the containers (services) we want to run

  web:                   # ğŸ‘ˆ This is the first service, called "web" (you can name it anything)
    build: .             # ğŸ‘ˆ Build the image from the Dockerfile in the current directory
    ports:
      - "5000:5000"      # ğŸ‘ˆ Map host port 5000 to container port 5000
    depends_on:
      - db               # ğŸ‘ˆ Wait for the "db" service to start before starting this one
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/mydb  # ğŸ‘ˆ Set env vars inside container

  db:                    # ğŸ‘ˆ Second service: the database
    image: postgres:13   # ğŸ‘ˆ Use the official Postgres image version 13
    environment:
      POSTGRES_USER: postgres         # ğŸ‘ˆ Create user "postgres"
      POSTGRES_PASSWORD: password     # ğŸ‘ˆ Set password
      POSTGRES_DB: mydb               # ğŸ‘ˆ Create database named "mydb"
    volumes:
      - db_data:/var/lib/postgresql/data  # ğŸ‘ˆ Persist database data using a named volume

volumes:                 # ğŸ‘ˆ Declare the named volume used by the db
  db_data:


ğŸ§  Explanation of Structure
----------------------------

| Part          | What it Does                                                              |
| ------------- | ------------------------------------------------------------------------- |
| `version`     | Declares Compose syntax version (use `"3.8"` for most modern setups)      |
| `services`    | The containers you want to run                                            |
| `web`         | The Flask app (or frontend/backend)                                       |
| `build`       | Tells Compose to use your Dockerfile in that directory to build the image |
| `image`       | Use a pre-built image from Docker Hub                                     |
| `ports`       | Maps container ports to your computer's ports                             |
| `depends_on`  | Ensures `db` starts before `web`                                          |
| `environment` | Defines environment variables (used for DB credentials, config, etc.)     |
| `volumes`     | Persistent storage for data (so DB isnâ€™t wiped every time you restart)    |

ğŸ”§ Folder Structure Example

my-project/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ app/
â”‚   â””â”€â”€ app.py
â”œâ”€â”€ requirements.txt


ğŸš€ How to Use It
------------------

In the folder with the docker-compose.yml, run:

docker-compose up --build

This will:
----------

Build the Flask app image

Start the Postgres DB

Connect them automatically

Print logs in your terminal


Q and A:
--------

âœ… Question 1: What is db_data:/var/lib/postgresql/data?
==========================================================
volumes:
  - db_data:/var/lib/postgresql/data

Means:

db_data â†’ is the name of a volume managed by Docker. Think of it like a special persistent storage space created and maintained by Docker itself.

/var/lib/postgresql/data â†’ is the path inside the container where PostgreSQL stores its database files.

So it connects them like this:

â€œStore the contents of /var/lib/postgresql/data (inside the container) into the Docker volume named db_data (on your real machine).â€

âœ… This means:
----------------

If the container dies or is deleted, your database data is still safe in db_data.

This does not mean it's a path on your host PC like /home/user â€” it's not using your own PC folders directly.

Docker stores volumes in a special place (like /var/lib/docker/volumes/... internally), managed by the Docker Engine.

âœ… Question 2: What is version: "3.8" in Docker Compose?
==========================================================

This line: version: "3.8"

Means:

"We are using version 3.8 of the Docker Compose file syntax."

It has nothing to do with your Docker version or Docker Engine version directly.

It just tells Docker Compose which features are available in the YAML file.

For example, newer syntax like depends_on, resource limits, or networks might behave differently in different versions.

Best practice?
Just use the latest stable version (3.8 is great and widely used).

âœ… Question 3: I have 3 projects in subfolders. How to structure Docker Compose?
==================================================================================

Letâ€™s say your folder structure is like this:

project/
â”œâ”€â”€ project1/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ app.py
â”œâ”€â”€ project2/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ main.js
â”œâ”€â”€ project3/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ server.go
â””â”€â”€ docker-compose.yml

You can write a single docker-compose.yml in the project/ folder like this:

version: "3.8"

services:
  app1:
    build: ./project1
    ports:
      - "5001:5000"

  app2:
    build: ./project2
    ports:
      - "5002:3000"

  app3:
    build: ./project3
    ports:
      - "5003:8080"


Explanation:

build: ./project1 â†’ Go into the project1 folder and use its Dockerfile to build the image.

Same for project2, project3.

ports: map different host ports so all apps can run together without clashing.

Now you can run all 3 apps together with:

	docker-compose up --build


Q: so how should the routing happnes , like lest say i have a asp.net app and i have psotgre sql database , so what should be the postgresql databases link tha ti should put in asp.net application?

A: 

ğŸ§± Example Folder Structure

myproject/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ aspnet-app/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ appsettings.json
â”œâ”€â”€ db/ (optional, for init scripts or volume stuff)

ğŸ“ docker-compose.yml example:
-------------------------------

version: "3.8"

services:
  web:
    build: ./aspnet-app
    ports:
      - "8080:80"
    depends_on:
      - db
    environment:
      - ConnectionStrings__DefaultConnection=Host=db;Port=5432;Database=mydb;Username=postgres;Password=pass123

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: pass123
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:



ğŸ”‘ How the ASP.NET App Connects to PostgreSQL
---------------------------------------------------

In your ASP.NET app, your appsettings.json should have something like:

{
  "ConnectionStrings": {
    "DefaultConnection": "Host=db;Port=5432;Database=mydb;Username=postgres;Password=pass123"
  }
}

OR you can override it using an environment variable as we did in Compose:

ConnectionStrings__DefaultConnection=Host=db;Port=5432;Database=mydb;Username=postgres;Password=pass123

Notice:

Host=db â†’ refers to the PostgreSQL container by its service name (db), not localhost.

5432 â†’ is the default PostgreSQL port (inside container)

Credentials match whatâ€™s declared in the Compose db service


âš ï¸ Common Mistake
-------------------

Don't use localhost as the DB host inside your ASP.NET container.

That would point to the container itself, not the Postgres container.


======================================
Docker compose project of kodekloud
=======================================

version: '3.8'

services:
  redis: 
    image: redis
  
  db
   image: postgres:9.4
   environment:				#environmental variables
     POSTGRES_USER: postgres
     POSTGRES_PASSWORD: postgres
  
  vote
    image: voting-app
    ports:
      - 5000:80
    links:
      - redis
  
  worker
    image: worker-app
    links:
      - db
      -	redis
  
  result:
    image: result-app
    port:
      - 5001:80
    links:
      - db
      
